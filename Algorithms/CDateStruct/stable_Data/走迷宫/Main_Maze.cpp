#include "Status.h"

struct PosType//坐标位置类型
{
	int x;//行值
	int y;//列值
};

PosType begin;//定义入口坐标
PosType end;//定义出口坐标
PosType direc[4]; //= {{0,1},{1,0},{0,-1},{-1,0}};PosTyepe型的一维数组，每个元素代表一个方向，在此分别为“东南西北”四个方向；

#define MAXLENGTH 35//迷宫最大行和列初始值
typedef int MazeType[MAXLENGTH][MAXLENGTH];//迷宫数组类型

MazeType m,dirc_mark,back_up;//迷宫数组m，记录方向信息的数组dirc_mark,以及用于备份初始化后的迷宫m的数组back_up
int x,y;//行和列

int direc_seq[4];//存储方向编号
Status me_mark;//标记探索方式（手动或自动）；

char filename[20] = "NULL";//存储路径图的文件名
#define LEVEL_SUM 10//关卡总数
int level = 0;//关卡计数
int Level_score = 0;//关卡分数
int step_count;//步数统计
int fault_step_count;//撞墙统计
double Correct_rate;//正确率统计
int Score = 0;//累计得分
int Lose_times = 0;//失败次数






Status Date_Save(int save_type)
{
	FILE *fp;

	if (1 == save_type)
	{
		if ((fp = fopen("USERADVDATE.dLL","w")) == NULL)
		{
			return ERROR;
		}
		fprintf(fp,"%s %d %d",filename,level,Score);
	}
	else
	{
		if ((fp = fopen("USERDIYDATE.dLL","w")) == NULL)
		{
			return ERROR;
		}
		fprintf(fp,"%s",filename);
	}

	fclose(fp);
	fp = NULL;
	return OK;
}

Status Date_Read(int save_type)
{
	FILE *fp;

	if (1 == save_type)
	{
		if ((fp = fopen("USERADVDATE.dLL","r")) == NULL)
		{
			return ERROR;
		}
		fscanf(fp,"%s%d%d",&filename,&level,&Score);
	}
	else
	{
		if ((fp = fopen("USERDIYDATE.dLL","r")) == NULL)
		{
			return ERROR;
		}
		fscanf(fp,"%s",&filename);
	}

	fclose(fp);
	fp = NULL;
	return OK;
}

void Maze_Library_Init(int m_num,MazeType &copy_destination)
{
	void Maze_copy(MazeType m1,MazeType &m2);
	int i;
	printf("自动生成迷宫中(现在不要按任何键)，请稍等");
	for (i = 1; i >= 0;i--)
	{
		printf(".");
		Sleep(1000);
	}
	system("cls");
	switch(m_num)
	{
/*	case -1:
		{
		  MazeType lib_m9 = {
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
								{1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1},
								{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
		
							};
		  x = 19;y = 19;
		  begin.x = 17;
	      begin.y = 1;
		  end.x = 9;
		  end.y = 9;
		  Level_score = 148;
		  Maze_copy(lib_m9,copy_destination);
		};
	break;
*/

	case 0:
		{
		  MazeType lib_m0 = {
								{0,0,0,0,0,0,0,0,0,0},
								{1,1,1,1,1,1,1,1,1,0},
								{0,1,0,1,0,1,0,1,0,0},
								{0,1,0,0,0,0,1,1,1,0},
								{0,1,1,0,1,1,1,0,1,0},
								{0,1,0,0,0,1,1,1,0,0},
								{0,1,0,1,1,1,0,0,1,0},
								{0,1,1,1,0,1,1,1,1,0},
								{0,1,0,1,0,0,1,0,1,0},
								{0,0,0,0,0,0,0,0,1,0},
							  };
		  x = 10;y = 10;
		  begin.x = 1;
	      begin.y = 0;
		  end.x = 9;
		  end.y = 8;
		  Level_score = 118;
		  Maze_copy(lib_m0,copy_destination);
		};
		break;
	case 1:
		{
		  MazeType lib_m1 = {
								{0,0,0,0,0,0,0,0,0,0},
								{1,1,0,1,0,1,0,1,1,0},
								{0,1,0,1,1,1,1,0,1,0},
								{0,1,0,1,0,1,0,1,0,0},
								{0,1,0,1,1,1,1,0,1,0},
								{0,1,0,1,0,1,0,1,0,0},
								{0,1,1,1,0,1,1,1,1,0},
								{0,1,0,1,0,1,0,1,0,0},
								{0,1,0,1,1,0,0,1,1,0},
								{0,0,0,0,0,0,0,0,1,0},
							  };
		  x = 10;y = 10;
		  begin.x = 1;
	      begin.y = 0;
		  end.x = 9;
		  end.y = 8;
		  Level_score = 120;
		  Maze_copy(lib_m1,copy_destination);
		}
		  break;
	case 2:
		{
		  MazeType lib_m2 = {
								{0,0,0,0,0,0,0,0,0,0},
								{1,1,1,0,1,1,1,1,1,0},
								{0,1,1,0,1,1,1,0,1,0},
								{0,1,1,1,1,0,0,1,0,0},
								{0,1,0,0,0,1,1,1,1,0},
								{0,1,1,1,0,1,0,1,0,0},
								{0,1,0,1,1,1,0,1,1,0},
								{0,1,0,1,0,1,0,0,1,0},
								{0,1,1,1,1,1,1,0,1,0},
								{0,0,0,0,0,0,0,0,1,0},
		
							};
		  x = 10;y = 10;
		  begin.x = 1;
	      begin.y = 0;
		  end.x = 9;
		  end.y = 8;
		  Level_score = 120;
		  Maze_copy(lib_m2,copy_destination);
		}
		  break;
	case 3:
		{
		  MazeType lib_m3 = {
								{0,0,0,0,0,0,0,0,0,0,0},
								{1,1,1,1,1,1,1,1,1,1,0},
								{0,0,0,1,0,0,0,0,0,0,0},
								{0,1,1,1,1,1,1,1,1,1,0},
								{0,1,0,1,0,0,0,0,1,0,0},
								{0,1,1,0,1,1,1,1,1,1,0},
								{0,0,0,0,1,0,0,0,1,0,0},
								{0,1,1,1,1,1,1,1,0,1,0},
								{0,0,1,0,1,0,1,0,0,0,0},
								{0,1,1,1,0,1,1,1,1,1,0},
								{0,0,0,0,0,0,0,0,0,0,0},
							 };
		  x = 11;y = 11;
		  begin.x = 1;
	      begin.y = 0;
		  end.x = 9;
		  end.y = 9;
		  Level_score = 125;
		  Maze_copy(lib_m3,copy_destination);
		}
		  break;
	case 4:
		{
		  MazeType lib_m4 = {
								{0,0,0,0,0,0,0,0,0,0,0},
								{1,1,1,1,1,1,1,0,1,0,0},
								{0,1,0,1,0,1,0,1,1,0,0},
								{0,1,1,0,1,1,1,1,1,1,0},
								{0,1,1,1,0,1,0,0,1,0,0},
								{0,1,0,1,1,0,1,1,1,1,0},
								{0,1,1,1,0,1,0,1,0,0,0},
								{0,1,0,1,1,1,1,1,1,1,0},
								{0,1,0,1,0,1,0,1,0,0,0},
								{0,1,1,0,1,0,1,1,1,1,0},
								{0,0,0,0,0,0,0,0,0,0,0},
							 };
		  x = 11;y = 11;
		  begin.x = 1;
	      begin.y = 0;
		  end.x = 9;
		  end.y = 9;
		  Level_score = 117;
		  Maze_copy(lib_m4,copy_destination);
		}
		  break;
	case 5:
		{
		  MazeType lib_m5 = {
								{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								{0,0,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0},
								{0,0,0,0,1,0,0,0,1,0,0,1,1,1,0,0,0,1,0},
								{0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0},
								{0,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,0},
								{0,1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,0,0,0},
								{0,1,1,0,1,1,1,1,1,1,1,0,0,1,1,0,0,1,0},
								{0,1,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,0},
								{0,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0},
								{0,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,0},
								{0,1,1,0,1,1,0,1,1,1,1,1,1,0,0,0,1,1,0},
								{0,1,0,1,1,1,0,1,1,0,1,1,1,0,1,0,1,1,0},
								{0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0},
								{0,1,0,0,1,1,0,1,0,1,0,1,1,0,1,1,0,1,0},
								{0,1,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0},
								{0,1,0,0,1,1,0,1,1,0,0,1,1,1,0,0,1,1,0},
								{0,1,1,1,1,0,0,0,1,1,0,0,1,0,1,1,0,1,0},
								{0,1,1,1,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0},
								{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		
							};
		  x = 19;y = 19;
		  begin.x = 17;
	      begin.y = 1;
		  end.x = 1;
		  end.y = 17;
		  Level_score = 132;
		  Maze_copy(lib_m5,copy_destination);
		}
		  break;
	case 6:
		{
		  MazeType lib_m6 = {
								{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								{0,1,1,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0},
								{0,1,0,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0},
								{0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,0,1,0},
								{0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,0,0,1,0},
								{0,0,1,1,1,0,0,1,0,0,1,1,1,0,1,1,1,1,0},
								{0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0},
								{0,1,1,0,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0},
								{0,1,1,0,0,1,0,0,1,1,0,1,1,0,1,1,0,1,0},
								{0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,0},
								{0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,0,1,1,0},
								{0,1,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0},
								{0,1,1,1,1,0,1,0,0,1,1,0,0,0,1,1,1,1,0},
								{0,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,1,0},
								{0,1,0,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0},
								{0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,1,0,1,0},
								{0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,0,1,0},
								{0,1,1,0,0,1,0,0,0,1,1,1,1,0,1,1,1,1,0},
								{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		
							};
		  x = 19;y = 19;
		  begin.x = 17;
	      begin.y = 1;
		  end.x = 17;
		  end.y = 14;
		  Level_score = 155;
		  Maze_copy(lib_m6,copy_destination);
		}
		  break;
	case 7:
		{
		  MazeType lib_m7 = {
								{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
								{0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
								{0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0},
								{0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0},
								{0,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0},
								{0,1,0,1,0,1,0,1,0,0,1,0,0,1,0,0,1,1,0},
								{0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,1,0,1,0},
								{0,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,0,1,0},
								{0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0},
								{0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0},
								{0,1,0,1,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0},
								{0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0},
								{0,1,0,1,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0},
								{0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0},
								{0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0},
								{0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},
								{0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
								{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
							};
		  x = 19;y = 19;
		  begin.x = 17;
	      begin.y = 1;
		  end.x = 9;
		  end.y = 9;
		  Level_score = 188;
		  Maze_copy(lib_m7,copy_destination);
		}
		  break;
	case 8:
		{
		  MazeType lib_m8 = {
								{0.0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								{1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0},
								{0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,0,1,1,0},
								{0,1,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,1,0},
								{0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0},
								{0,1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0},
								{0,1,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,1,0},
								{0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,0},
								{0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0},
								{0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0},
								{0,1,0,1,0,0,0,1,1,0,1,1,0,0,0,1,0,1,0},
								{0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0},
								{0,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0},
								{0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0},
								{0,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,0},
								{0,1,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,1,0},
								{0,1,1,0,1,0,1,1,0,0,0,1,1,0,1,0,1,1,0},
								{0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0},
								{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		
							};
		  x = 19;y = 19;
		  begin.x = 1;
	      begin.y = 0;
		  end.x = 9;
		  end.y = 9;
		  Level_score = 167;
		  Maze_copy(lib_m8,copy_destination);
		}
		  break;
	case 9:
		{
		  MazeType lib_m9 = {
								{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								{0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0},
								{0,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,0,1,0},
								{0,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,0},
								{0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0},
								{0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0},
								{0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0},
								{0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0},
								{0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0},
								{0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,0,1,0},
								{0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0},
								{0,0,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,0},
								{0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0},
								{0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,1,0},
								{0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0},
								{0,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,0},
								{0,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,0,1,0},
								{0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0},
								{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
		
							};
		  x = 19;y = 19;
		  begin.x = 17;
	      begin.y = 1;
		  end.x = 9;
		  end.y = 9;
		  Level_score = 148;
		  Maze_copy(lib_m9,copy_destination);
		}
		  break;
	}
	Maze_copy(copy_destination,back_up);
	return;

}

void Print(MazeType m)//输出迷宫格局(数字表示)
{
	int i,j;
	
	for (i = 0; i < x; i++)
	{
		for (j = 0; j < y; j++)
		{
			printf("%-3d",m[i][j]);
		}
		printf("\n");
	}
	printf("\n");
	printf("      0=墙      1=通道 \n\n");
}

void Print_To_File(Status explor_type,FILE* fp,MazeType m)//输出迷宫格局(数字表示）到文件中
{
	int i,j;
	if (explor_type)
	{
		fprintf(fp,"1.按照：%d - %d - %d - %d的顺序(0=东，1=南，2=西，3=北)迷宫路线(数字表示)为：\n\n",direc_seq[0],direc_seq[1],direc_seq[2],direc_seq[3]);
	}
	else
	{
		fprintf(fp,"1.通过手动探索所得的迷宫路线图(数字表示)：\n\n");
	}
	for (i = 0; i < x; i++)
	{
		for (j = 0; j < y; j++)
		{
			fprintf(fp,"%3d",m[i][j]);
		}
		fprintf(fp,"\n");
	}
	fprintf(fp,"\n\n");
	fprintf(fp,"    0=墙      1=通道       -1=失败路径      >1=路线\n\n\n");
}

void Print_Image(MazeType m,int x,int y,PosType begin,PosType curpos,PosType end,Status image_type)//输出迷宫格局(图形表示)
{
	int i,j;
	if (-1 == image_type)
	{
		printf("\t\t\t\t\t\t");
	}
	else if (-2 == image_type)
	{
		printf("\t\t\t\t\t");
	}
	for(i = 0; i < x; i++)
	{
		for(j = 0; j < y; j++)
		{
			if(m[i][j] == 0)//如果为0则输出代表墙的图形"■"
			{
				printf("■");//墙体
			}
			else
			{
				if(i == curpos.x && j == curpos.y)//如果循环到探险者位置，则输出"●"或"★"。
				{
					if (curpos.x == end.x && curpos.y == end.y)//达到出口后输出★""
					{
						printf("★");//成功
					}
					else 
					{
						if (-1 == image_type)
						{
							putchar(' ');
							putchar(' ');
						}
						else
						{
							printf("●");//探险者
						}
					}
				}
				else if(i == begin.x && j == begin.y)//如果循环到入口处，则输出"○"
				{
					printf("○");//入口位置
				}
				else if(i == end.x && j == end.y)//如果循环到出口处，则输出□""
				{
					if (-1 == image_type)
					{
						putchar(' ');
						putchar(' ');
					}
					else
					{
						printf("□");//目标点（出口）
					}
				}
				else
				{
					if (m[i][j] < 0)//经试探而不能到达终点的路径（-1）,输出"×"
					{
						printf("×");//不可通行
					}
					else if (m[i][j] > 1)//有足迹处，输出相应的方向
					{
						switch(dirc_mark[i][j])
						{
						case 0:
							{
								printf("→");//东
							}
							break;
						case 1:
							{
								printf("↓");//南
							}
							break;
						case 2:
							{
								printf("←");//西
							}
							break;
						default:
							{
								printf("↑");//北
							}				
						}
					}
					else 
					{
						if (image_type)
						{
							putchar(' ');
							putchar(' ');
						}
						else
						{
							printf("■");
						}
						
					}
				}
			}
			
		}
		if (-1 == image_type)//倒计时和例子
		{
			printf("\n\t\t\t\t\t\t");
		}
		else if (-2 == image_type)
		{
			printf("\n\t\t\t\t\t");
		}
		else
		{
			printf("\n");
		}
	}
	printf("\n");
	if (1 == me_mark)
	{
		printf("'●'=探险者'■'=墙（或被遮蔽）'○'=入口（起始点）'□'=出口'★'=到达 '→'=足迹'×'=失败路径\n\n");
	}
    
	else if (2 == me_mark && image_type != -1 && image_type != -2)
	{
		printf("'●'=探险者'■'=墙'（或被遮蔽）○'=入口（起始点）'□'=出口'★'=到达\n\n");
	}
	else if (-1 == image_type || -2 == image_type)
	{
		;
	}
	else
	{
		printf(" '■'=墙  ‘ ’=通道\n\n");
	}
}

Status Print_Img_To_File(Status explor_type,FILE*fp,int x,int y,PosType begin,PosType end,Status image_type)//输出迷宫格局(图形表示)到文件中
{
	int i,j;
	if (0 == image_type && 1 == explor_type)//DIY模式下的自动探索
	{
		fprintf(fp,"按照：%d - %d - %d - %d的顺序(0=东，1=南，2=西，3=北)迷宫路线(图形表示)为：\n\n",direc_seq[0],direc_seq[1],direc_seq[2],direc_seq[3]);
	}
	else if (0 == image_type && -1 == explor_type)//冒险模式下的探索方式
	{
		fprintf(fp,"第%d关：\n\n",level - 1);
	}
	else if (0 == explor_type && 0 == image_type)//DIY模式下的手动探索
	{
		fprintf(fp,"通手动探索所得的迷宫路线图（图形表示）：\n\n");
	}

	for(i = 0; i < x; i++)
	{
		for(j = 0; j < y; j++)
		{
			if(m[i][j] == 0)//如果为0则输出代表墙的图形"■"
			{
				fprintf(fp,"■");//墙体
			}
			else
			{
				if(i == begin.x && j == begin.y)//如果循环到入口处，则输出"○"
				{
					fprintf(fp,"○");//入口位置
				}
				else if(i == end.x && j == end.y)//如果循环到探险者位置，则输出"●"或"★"。
				{
					fprintf(fp,"★");//成功
				}
				else
				{
					if (m[i][j] < 0)//经试探而不能到达终点的路径（-1）,输出"×"
					{
						fprintf(fp,"×");//不可通行
					}
					else if (m[i][j] > 1)//有足迹处，输出相应的方向
					{
						switch(dirc_mark[i][j])
						{
						case 0:
							{
								fprintf(fp,"→");//东
							}
							break;
						case 1:
							{
								fprintf(fp,"↓");//南
							}
							break;
						case 2:
							{
								fprintf(fp,"←");//西
							}
							break;
						default:
							{
								fprintf(fp,"↑");//北
							}				
						}
					}
					else 
					{
						if (image_type)
						{
							fprintf(fp," ");
							fprintf(fp," ");
						}
						else
						{
							fprintf(fp,"■"); 
						}
						
					}
				}
			}
		}
		fprintf(fp,"\n");
	}
	fprintf(fp,"\n");
	if (image_type)
	{
		if ((1 == level && -1 == explor_type) || 0 == explor_type)
		{
			fprintf(fp,"'●'=探险者 '■'=墙(或遮蔽) '○'=入口（起始点）'□'=出口 '★'=到达  '→'=足迹 \n");
			fprintf(fp,"\n失败次数%d，一共花了%d步走出此迷宫，期间撞墙%d次，正确率%.2f%%\n\n\n\n\n",Lose_times,step_count,fault_step_count,Correct_rate*100);
		}
		else if (1 < level && -1 == explor_type)
		{
			fprintf(fp,"失败次数%d，一共花了%d步走出此迷宫，期间撞墙%d次，正确率%.2f%%",Lose_times,step_count,fault_step_count,Correct_rate*100);
			fprintf(fp,"\n\n本关您的得分为%d分，累计得分%d分。\n\n\n\n",Level_score - (step_count + fault_step_count),Score);
		}
		else if (1 == explor_type)
		{
			fprintf(fp,"'●'=探险者 '■'=墙(或遮蔽) '○'=入口（起始点）'□'=出口 '★'=到达  '→'=足迹 '×'=失败路径\n\n\n\n\n");
		}
	}

	return OK;
	
}


Status FileMake(Status explor_type,FILE* &fp)
{
	char ch;
	Status st;
	while((ch=getchar()) != '\n');
	printf("\n\n是否存放到上次创建的文件中？(Y/N)(如果没有创建过文件请选N):");
	scanf(" %c",&ch);
	
	do
	{
		if ('Y' != ch && 'y' != ch)
		{
			while((ch=getchar()) != '\n');
			printf("\n\n请输入要创建的文件名(后加扩展名,如.txt):");
			scanf("%s",&filename);
		}
		else
		{
			if (!strcmp(filename,"NULL"))
			{
				printf("\n\n无法保存！您还没有创建过文件，请先创建！\n");
				ch = 'n';
			}
		}
	}while (!strcmp(filename,"NULL"));
	
	
	if ((fp = fopen(filename,"a+")) == NULL)
	{
		printf("Cannot open file!\n");
		return ERROR;
	}
	st = Print_Img_To_File(explor_type,fp,x,y,begin,end,0);
	st = Print_Img_To_File(explor_type,fp,x,y,begin,end,1);
	fclose(fp);
	fp = NULL;
	printf("\n\n已成功存储到%s中！\n\n",filename);
    Sleep(1000);
	
	return st;
}

void FileMake_ask(FILE * &fp,Status &st,Status explor_type)
{
	char ch;
	printf("\n是否将探索过的路径图导出到文件中(Y/N):");
	scanf(" %c",&ch);
	if ('Y'== ch || 'y' == ch)
	{
		st = FileMake(explor_type,fp);
	}	
}

void Countdown(void)
{
	static int count_num = 3;
	PosType c_begin = {-2,-2},c_end = {-1,-1};
	printf("\n\n\n\n\n\n\n\n\n\n");
	switch(count_num)
	{ 
	case 3:
		{
			count_num--;
		    MazeType countdown= {
									{0,0,0,0,0,0,0,0,0,0},
									{0,0,0,0,0,0,0,0,0,0},
									{1,1,1,1,1,1,1,1,0,0},
									{1,1,1,1,1,1,1,1,0,0},
									{0,0,0,0,0,0,0,0,0,0},
									{0,0,0,0,0,0,0,0,0,0},
									{1,1,1,1,1,1,1,1,0,0},
									{1,1,1,1,1,1,1,1,0,0},
									{0,0,0,0,0,0,0,0,0,0},
									{0,0,0,0,0,0,0,0,0,0},
								};
			Print_Image(countdown,10,10,c_begin,c_begin,c_end,-1);
			Sleep(1000);
			system("cls");
		}
		break;
	case 2:
		{
			count_num--;
		    MazeType countdown = {
									{0,0,0,0,0,0,0,0,0,0},
									{0,0,0,0,0,0,0,0,0,0},
									{1,1,1,1,1,1,1,1,0,0},
									{1,1,1,1,1,1,1,1,0,0},
									{0,0,0,0,0,0,0,0,0,0},
									{0,0,0,0,0,0,0,0,0,0},
									{0,0,1,1,1,1,1,1,1,1},
									{0,0,1,1,1,1,1,1,1,1},
									{0,0,0,0,0,0,0,0,0,0},
									{0,0,0,0,0,0,0,0,0,0},
								};	
			Print_Image(countdown,10,10,c_begin,c_begin,c_end,-1);
			Sleep(1000);
			system("cls");
		}
		break;
	case 1:
		{
			count_num--;
		    MazeType countdown = {
									{1,1,1,1,0,0,1,1,1,1},
									{1,1,1,1,0,0,1,1,1,1},
									{1,1,1,1,0,0,1,1,1,1},
									{1,1,1,1,0,0,1,1,1,1},
									{1,1,1,1,0,0,1,1,1,1},
									{1,1,1,1,0,0,1,1,1,1},
									{1,1,1,1,0,0,1,1,1,1},
									{1,1,1,1,0,0,1,1,1,1},
									{1,1,1,1,0,0,1,1,1,1},
									{1,1,1,1,0,0,1,1,1,1},
								};	
			Print_Image(countdown,10,10,c_begin,c_begin,c_end,-1);
			Sleep(1000);
			system("cls");
		}
		break;
	}
	if (0 == count_num)
	{
		count_num = 3;
	}
	return;
}

void victory(void)
{
	static int cp = 1;
	PosType p_begin = {-2,-2},p_end = {-1,-1};
	printf("\n\n\n\n\n\n\n\n\n\n");
	switch(cp)
	{ 
	case 1:
		{
			cp++;
		    MazeType pic= {
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
		
								};
			Print_Image(pic,19,19,p_begin,p_begin,p_end,-2);
			Sleep(100);
			system("cls");
		}
		break;
	case 2:
		{
			cp++;
		    MazeType pic = {
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1},
								{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
								};	
			Print_Image(pic,19,19,p_begin,p_begin,p_end,-2);
			Sleep(100);
			system("cls");
		}
		break;
	case 3:
		{
			cp++;
		    MazeType pic = {
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,0,1,1,1,1,0,0,0,1,1,0,1,1,1,1},
								{1,1,1,0,1,0,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
								};	
			Print_Image(pic,19,19,p_begin,p_begin,p_end,-2);
			Sleep(100);
			system("cls");
		}
		break;
	case 4:
		{
			cp++;
		    MazeType pic = {
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,0,0,1,0,1,0,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
								};	
			Print_Image(pic,19,19,p_begin,p_begin,p_end,-2);
			Sleep(100);
			system("cls");
		}
		break;
	case 5:
		{
			cp++;
		    MazeType pic = {
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1},
								{1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
								};	
			Print_Image(pic,19,19,p_begin,p_begin,p_end,-2);
			Sleep(100);
			system("cls");
		}
		break;
	case 6:
		{
			cp++;
		    MazeType pic = {
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,0,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
								};	
			Print_Image(pic,19,19,p_begin,p_begin,p_end,-2);
			Sleep(100);
			system("cls");
		}
		break;
	case 7:
		{
			cp++;
		    MazeType pic = {
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,0,1,0,1,1,0,1,1,1,1,1,0,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
								};	
			Print_Image(pic,19,19,p_begin,p_begin,p_end,-2);
			Sleep(100);
			system("cls");
		}
		break;
	case 8:
		{
			cp++;
		    MazeType pic = {
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1},
								{1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,0,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
								};	
			Print_Image(pic,19,19,p_begin,p_begin,p_end,-2);
			Sleep(100);
			system("cls");
		}
		break;
	case 9:
		{
			cp++;
		    MazeType pic = {
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1},
								{1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1},
								{1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1},
								{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,1,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1},
								{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
								};	
			Print_Image(pic,19,19,p_begin,p_begin,p_end,-2);
			Sleep(100);
			system("cls");
		}
		break;
	}
	if (10 == cp)
	{
		cp = 6;
	}
	return;
}

void Init(void)//布置迷宫格局
{  
	void Maze_copy(MazeType m1,MazeType &m2);
	int i,j;
	int x1,x2;
	char ch;
	PosType null = {-1,-1};

	printf("/***************************************************【DIY即时布局ing】*****************************************************/\n");
	while((ch=getchar()) != '\n');
	printf("\n请输入迷宫的行数和列数(行数和列数不能超过35，并以英文逗号分隔)：\n");
	scanf("%d,%d",&x,&y);
	while (x < 3 || x > 35 || y < 3 || y > 35)
	{
		printf("\n输入范围或格式有误请重新输入!;\n");
		scanf("%d,%d",&x,&y);
	}
	
	for (i = 0;i < y; i++)//设置迷宫上下围墙(用0表示)
	{
		m[0][i] = 0;     //最上行
		m[x -1][i] = 0;	 //最下行
	}
	
	for (i = 1; i < x - 1; i++)//设置迷宫左右围墙
	{
		m[i][0] = 0;     //最左列
		m[i][y-1] = 0;     //最右列
	}
	
	for (i = 1; i < x - 1; i++)//定义出围墙外，其余都是通道（初始值为1）
	{
		for (j = 1; j < y - 1; j++)
		{
			m[i][j] = 1;
		}
	}
	
	printf("\n以下是未设内墙的%d×%d的迷宫：\n\n",x,y);
	printf("1.用数字表示的迷宫图：\n\n");
	Print(m);
	
	printf("\n2.用图形表示的迷宫图：\n\n");
	Print_Image(m,x,y,null,null,null,1);
	
	printf("\n/*----------------------------------------------------------------------------*/\n");
	Sleep(1000);
	while((ch=getchar()) != '\n');
	printf("\n请输入要设置的内墙的数量(不能超过%d):\n",(x-2)*(y-2));//设置内墙数
	scanf("%d",&j);
	while (j < 0 || j > (x - 2)*(y - 2))
	{
		while((ch=getchar()) != '\n');
		printf("\n输入范围或格式有误请重新输入;\n");
		scanf("%d",&j);
	}
	if (j > 0)
	{
		while((ch=getchar()) != '\n');
		printf("\n请输入要设置墙的行和列(行列间以英文输入法状态下的逗号分隔,比如 2,3 每输完一个按回车)：\n");
		for (i = 0; i < j; i++)//设置内墙（用0表示）
		{
			scanf("%d,%d",&x1,&x2);
			while (x1 < 1 || x1 > x  || x2 < 1 || x2 > y )
			{
				while((ch=getchar()) != '\n');
				printf("\n输入范围或格式有误请重新输入;\n");
				scanf("%d,%d",&x1,&x2);
			}
			m[x1-1][x2-1] = 0;
		}
	}
	while((ch=getchar()) != '\n');
	printf("\n请输入迷宫入口的行和列，可设在有墙处（行和列间以英文逗号分隔，输完按回车）：\n");
	scanf("%d,%d",&begin.x,&begin.y);
	begin.x--;
	begin.y--;
	while (begin.x < 0 || begin.x > x - 1 || begin.y < 0 || begin.y > y - 1)
	{
		while((ch=getchar()) != '\n');
		printf("\n输入范围或格式有误请重新输入;\n");
		scanf("%d,%d",&begin.x,&begin.y);
		begin.x--;
		begin.y--;
	}
	m[begin.x][begin.y] = 1;

	while((ch=getchar()) != '\n');
	printf("\n请输入迷宫出口的行和列（行和列间以逗号分隔，输完按回车）：\n");
	scanf("%d,%d",&end.x,&end.y);
	end.x--;
	end.y--;
	
	while (end.x < 0 || end.x > x - 1 || end.y < 0 || end.y > y - 1||(end.x == begin.x && end.y == begin.y))
	{
		while((ch=getchar()) != '\n');
		printf("\n输入范围或格式有误请重新输入:\n");
		scanf("%d,%d",&end.x,&end.y);
		end.x--;
		end.y--;
	}
	m[end.x][end.y] = 1;
	
	Maze_copy(m,back_up);
    printf("\n/*----------------------------------------------------------------------------*/\n");
	Sleep(1000);
	printf("\n按照您的输入，迷宫的格局如下：\n\n");
	printf("1.用数字表示的迷宫图：\n\n");
	Print(m);
	
	Sleep(1000);
	printf("\n2.用图形表示的迷宫图：\n\n");
	Print_Image(m,x,y,begin,begin,end,1);
	
	printf("\n/*----------------------------------------------------------------------------*/\n");
	
	return;
}

Status Import_Init(void)
{
	void Maze_copy(MazeType m1,MazeType &m2);
	FILE*fp;
	int i,j;
	char import_name[20];
	char ch;
	PosType ex_begin = {1,0},ex_end = {9,8};
	printf("/****************************************************【DIY导入文件ing】*****************************************************/\n");
	printf("\n\n【导入说明】：1.导入的文件必须和程序在同一个存放位置；\n\n\t      2.文件名中无空格，格式为.txt格式。\n");
	printf("\n【文件内容】：导入的文件内容必须是以0和1构成的矩阵图（0代表墙，1代表通道）\n\n\t      不能有其他数字,且矩阵元素间以空格分隔。\n");
	printf("\n请参考以下导入文件的格式进行编辑：\n\n");
    MazeType example_m = {
		{0,0,0,0,0,0,0,0,0,0},
		{1,1,1,1,1,1,1,1,1,0},
		{0,1,0,0,1,1,0,0,1,0},
		{0,1,0,0,1,1,0,0,1,0},
		{0,1,1,1,1,1,1,1,1,0},
		{0,1,1,1,0,0,1,1,1,0},
		{0,1,0,1,1,1,1,0,1,0},
		{0,1,0,0,0,0,0,0,1,0},
		{0,1,1,1,1,1,1,1,1,0},
		{0,0,0,0,0,0,0,0,1,0},
	};
	x = y = 10;
	Print(example_m);
	printf("\n程序会将导入的文件自动转化为图形表示的迷宫，如下图：\n\n");
	Print_Image(example_m,x,y,ex_begin,ex_begin,ex_end,-1);
	printf("\n如果您还未建立导入文件,可现在建立,完成后按Y进行导入,不想导入请按N:\n");
	scanf(" %c",&ch);
	if ('N' == ch || 'n' == ch)
	{
		return ERROR;
	}
	while ('Y'!= ch &&  'y'!= ch)
	{
		printf("\b");
		scanf(" %c",&ch);
	}
	while((ch=getchar()) != '\n');
	printf("\n\n导入文件前请输入所导入迷宫的行数和列数(行列间以英文输入法状态下的逗号分隔，行数和列数千万不能搞错！)：\n");
	scanf("%d,%d",&x,&y);	

	printf("\n\n请输入导入的文件名(一定要加后缀如.txt):");
	scanf("%s",&import_name);
	if ((fp = fopen(import_name,"r")) == NULL)
	{
		return ERROR;
	}
	for (i = 0; i < x; i++)
	{
		for (j = 0; j < y; j++)
		{
			fscanf(fp,"%d",&m[i][j]);
		}
	}
	system("cls");
	printf("/****************************************************【DIY导入文件ing】*****************************************************/\n");
    printf("\n导入成功！\n");

	printf("\n请输入迷宫入口的行和列，可设在有墙处（行和列间以英文逗号分隔，输完按回车）：\n");
	scanf("%d,%d",&begin.x,&begin.y);
	begin.x--;
	begin.y--;
	while (begin.x < 0 || begin.x > x - 1 || begin.y < 0 || begin.y > y - 1)
	{
		while((ch=getchar()) != '\n');
		printf("\n输入范围或格式有误请重新输入;\n");
		scanf("%d,%d",&begin.x,&begin.y);
		begin.x--;
		begin.y--;
	}
	m[begin.x][begin.y] = 1;

	while((ch=getchar()) != '\n');
	printf("\n请输入迷宫出口的行和列（行和列间以英文逗号分隔，输完按回车）：\n");
	scanf("%d,%d",&end.x,&end.y);
	end.x--;
	end.y--;
	
	while (end.x < 0 || end.x > x - 1 || end.y < 0 || end.y > y - 1||(end.x == begin.x && end.y == begin.y))
	{
		while((ch=getchar()) != '\n');
		printf("\n输入范围或格式有误请重新输入:\n");
		scanf("%d,%d",&end.x,&end.y);
		end.x--;
		end.y--;
	}
	m[end.x][end.y] = 1;
	
	Maze_copy(m,back_up);
    printf("\n/*----------------------------------------------------------------------------*/\n");
	Sleep(1000);
	printf("\n按照导入文件，迷宫的格局如下：\n\n");
	printf("1.用数字表示的迷宫图：\n\n");
	Print(m);
	
	Sleep(1000);
	printf("\n2.用图形表示的迷宫图：\n\n");
	Print_Image(m,x,y,begin,begin,end,1);
	
	printf("\n/*----------------------------------------------------------------------------*/\n");

	fclose(fp);
	fp = NULL;
	return OK;
}

void Maze_copy(MazeType m1,MazeType &m2)
{
	int i,j;
	for (i = 0; i < x; i++)
	{
		for (j = 0; j < y; j++)
		{
			m2[i][j] = m1[i][j];
		}
	}
	
	return;
}

void dirc_select(void)
{
	int i,j = 0;
	char ch;
	while((ch=getchar()) != '\n');
	printf("\n请选择程序自动探索时采用方向的先后顺序(0=东，1=南，2=西，3=北,序号间以空格分隔):\n");
	
	for (i = 0;i < 4; i++)
	{
		scanf("%d",&j);
		while (j < 0 || j > 3)
		{
			printf("\n输入超出范围或有误(0=东，1=南，2=西，3=北,并以空格分隔)，请重新输入:\n");
			scanf("%d",&j);
		}
		switch(j)
		{
		case 0:
			{
				direc[i].x = 0; //东
				direc[i].y = 1;
				direc_seq[i] = 0; 
			}
			break;
		case 1:
			{
				direc[i].x = 1; //南
				direc[i].y = 0;
				direc_seq[i] = 1;
			}
			break;
		case 2:
			{
				direc[i].x = 0; //西
				direc[i].y = -1;
				direc_seq[i] = 2;
			}
			break;
		case 3:
			{
				direc[i].x = -1; //北
				direc[i].y = 0;
				direc_seq[i] = 3;
			}
			break;
		}
	}
	
	return;
}

struct SElemType//定义栈元素的类型
{
	int ord;
	PosType seat;
	int di;
};
#include "struct SqStack.h"
#include "Basic_operation_functions.h"

Status Pass(PosType b)//当迷宫m的b点为1时，返回OK；否则返回ERROR；
{
	if (1 == m[b.x][b.y])
	{
		return OK;
	}
	else
	{
		return ERROR;
	}
}

int curstep;

void FootPrint(PosType b)//使迷宫m的b点的值变为足迹（curstep）
{
	m[b.x][b.y] = curstep;
	
	return;
}

void DircPrint(PosType b,int di)//使方向记录数组dirc_mark的b点值变为方向
{
	if (0 == direc[di].x && 1 == direc[di].y)
	{
		dirc_mark[b.x][b.y] = 0;//标记为东
	}
	else if (1 == direc[di].x && 0 == direc[di].y)
	{
		dirc_mark[b.x][b.y] = 1;//标记为南
	}
	else if (0 == direc[di].x && -1 == direc[di].y)
	{
		dirc_mark[b.x][b.y] = 2;//标记为西
	}
	else 
	{
		dirc_mark[b.x][b.y] = 3;//标记为北
	}
}

void H_DircPrint(PosType b,int di)
{
	switch (di)
	{
	case 0:
		{
			dirc_mark[b.x][b.y] = 0;//标记为东
		}
		break;
	case 1:
		{
			dirc_mark[b.x][b.y] = 1;//标记为南
		}
		break;
	case 2:
		{
			dirc_mark[b.x][b.y] = 2;//标记为西
		}
		break;
	case 3:
		{
			dirc_mark[b.x][b.y] = 3;//标记为北
		}
	}
	
}

void NextPos(PosType &b, int di)//b点向第di个方向移动
{
	b.x += direc[di].x;
	b.y += direc[di].y;
	
	return;
}

void H_NextPos(PosType &b, int di)
{
	switch (di)
	{
	case 0:
		{
			b.y++;//标记为东
		}
		break;
	case 1:
		{
			b.x++;//标记为南
		}
		break;
	case 2:
		{
			b.y--;//标记为西
		}
		break;
	case 3:
		{
			b.x--;//标记为北
		}
	}
	
	return;
}

Status H_Check(PosType b)
{
	int i;
	PosType b1;
	b1.x = b.x;b1.y = b.y ;
	
	for (i = 0; i < 4; i++)
	{
		H_NextPos(b,i);
		
		if (Pass(b))
		{
			return OK;
		}
		b.x = b1.x;b.y = b1.y ;
	}
	return ERROR;
}

void MarkPrint(PosType b)//使迷宫m的b点标记为-1（经试探而不能到达终点的路径）
{
	m[b.x][b.y] = -1;
	
	return;
}

void Adv_Model_Title(void)
{
	printf("/**************************************************【冒险模式ing】*************************************************/\n");
	return;
}
void DIY_Model_H_Title(void)
{
	printf("/*************************************************【DIY探险模式ing】*****************************************************/\n");
	return;
}
void DIY_Model_A_Title(void)
{
	printf("/*************************************************【DIY自动模式ing】*****************************************************/\n");
	return;
}

Status MazePath(PosType begin,PosType end,Status image_type)//若迷宫m中存在从入口start到出口end的通道，则求的一条存放在栈中（从栈底到栈顶），并返回TRUE；否者返回FALSE
{
	int i;
	char ch;
	system("cls");
	DIY_Model_A_Title();
	printf ("正在生成模拟对象，请稍后........");
	for (i = 3; i >= 0;i--)
	{		
		printf("\b\b\b\b\b(%d秒)",i);
		Sleep(1000);
	}
	me_mark = 1;
	step_count = 0;
	curstep = 1;
	PosType curpos = begin;//当前位置在入口
	SqStack S;         //顺序栈
	SElemType e;       //栈元素
	e.di = 0;
	InitStack(S);	   //初始化栈
	
	do
	{
		if (Pass(curpos))//当前位置可通过，即是未曾走到过的通道块
		{
			FootPrint(curpos);// 留下足迹
            step_count++;     //统计步数
			DircPrint(curpos,e.di);//记录方向
			Sleep(350);           //延迟刷新时间
			system("cls");         //刷新屏幕
			DIY_Model_A_Title();
			Print_Image(m,x,y,begin,curpos,end,image_type);//输出此时用图形表示的迷宫
			e.ord = curstep;
			e.seat = curpos;
			e.di = 0;
			Push(S,e);// 入栈当前位置及状态
			curstep++;// 足迹加1
			if (curpos.x  == end.x && curpos.y == end.y)// 到达终点(出口)
			{
				system("cls");
				DIY_Model_A_Title();
				Print_Image(m,x,y,begin,curpos,end,1);
				printf("\twin!\n\n");//成功
				printf("一共花了%d步走出此迷宫\n\n",step_count);
				printf("\n\n按任意键结束探索...");
				getch();
				return TRUE;
			}
			NextPos(curpos,e.di);// 由当前位置及移动方向，确定下一个当前位置			
		}
		else
		{ // 当前位置不能通过
			if (!IsStackEmpty(S))// 栈不空
			{
				Pop(S,e);// 退栈到前一位置
				curstep--; // 足迹减1
				while (3 == e.di && !IsStackEmpty(S))// 前一位置处于最后一个方向(北)
				{
					MarkPrint(e.seat);// 在前一位置留下不能通过的标记(-1)
					Pop(S,e);// 再退回一步
					curstep--;// 足迹再减1
				}
				
				if (e.di < 3)// 没到最后一个方向(北)
				{
					e.di++;// 换下一个方向探索
					Push(S,e);// 入栈该位置的下一个方向
					curstep++;// 足迹加1
					curpos = e.seat; // 确定当前位置
					NextPos(curpos,e.di);// 确定下一个当前位置是该新方向上的相邻块
				}
			}
		}
		
	}while (!IsStackEmpty(S));
	return FALSE;
}

void  MazePath_and_ask(FILE*&fp,Status &st)
{
	char ch;
		do
		{
			dirc_select();
			while((ch=getchar()) != '\n');
			printf("\n\n按任意键开始探索...");
			getch();
			
			if ( MazePath(begin,end,0))
			{
				system("cls");
				DIY_Model_A_Title();
				printf("\n");
				printf("1.按照：%d - %d - %d - %d的顺序(0=东，1=南，2=西，3=北)迷宫路线(数字表示)为：\n\n",direc_seq[0],direc_seq[1],direc_seq[2],direc_seq[3]);
				Print(m);
				printf("2.按照：%d - %d - %d - %d的顺序(0=东，1=南，2=西，3=北)迷宫路线(图形表示)为：\n\n",direc_seq[0],direc_seq[1],direc_seq[2],direc_seq[3]);
				Print_Image(m,x,y,begin,end,end,0);
				Print_Image(m,x,y,begin,end,end,1);
				FileMake_ask(fp,st,1);
				Date_Save(0);
			}
			else
			{
				system("cls");
				DIY_Model_A_Title();
				Print_Image(m,x,y,begin,end,end,1);
				printf("\n此迷宫没有从入口到出口的路径或探索方向输入有误！\n");
			}
			while((ch=getchar()) != '\n');
			printf("\n\n是否改变探索方向从起点开始再探索一遍？(Y/N):");
			scanf(" %c",&ch);
		    Maze_copy(back_up,m);
		}while ('Y'== ch || 'y' == ch);
}

Status MazeHpath(PosType begin, PosType end,Status image_type)//手动探索
{
	int i;
	printf ("正在生成模拟对象(现在请不要按任何键)，请稍后........");
	for (i = 5; i >= 0;i--)
	{	
		printf("\b\b\b\b\b(%d秒)",i);
		Sleep(1000);
	}
	me_mark = 2;
	char e,ch;
	curstep = 1;
	fault_step_count = 0;
	PosType perpos;
	PosType curpos = begin;
	step_count = 0;
	system("cls");
	if (level)
	{
		Adv_Model_Title();
	}
	else
	{
		DIY_Model_H_Title();
	}
	printf("\n\"路暗暗其修远兮，吾将上下左右而求路\"");
	printf("\n\n");
	Print_Image(m,x,y,begin,curpos,end,image_type);
	do
	{
		perpos = curpos;
		e = getch();
		switch (e)
		{
		case 'W':
			{
				e = 'w';
			}
			break;
		case 'A':
			{
				e = 'a';
			}
			break;
		case 'S':
			{
				e = 's';
			}
			break;
		case 'D':
			{
				e = 'd';
			}
		}
		switch (e)
		{
		case 'w':
			{
				curpos.x--;
				if (Pass(curpos))
				{
					H_DircPrint(curpos,3);
				}
			}
			break;
		case 'a':
			{
				curpos.y--;	
				if (Pass(curpos))
				{
					H_DircPrint(curpos,2);
				}
			}
			break;
		case 's':
			{
				curpos.x++;
				if (Pass(curpos))
				{
					H_DircPrint(curpos,1);
				}
			}
			break;
		case 'd':
			{
				curpos.y++;
				if (Pass(curpos))
				{
					H_DircPrint(curpos,0);
				}
			}
		}
		
		if (Pass(curpos))
		{
			system("cls");
			curstep++;
			FootPrint(curpos);
			if (level)
			{
				Adv_Model_Title();
			}
			else
			{
				DIY_Model_H_Title();
			}
			printf("\n\n\n");
			Print_Image(m,x,y,begin,curpos,end,image_type);
			step_count++;
			if (curpos.x == end.x && curpos.y == end.y)
			{
				system("cls");
				if (level)
				{
					Adv_Model_Title();
				}
				else
				{
					DIY_Model_H_Title();
				}
				printf("\n\n\n");
				Print_Image(m,x,y,begin,curpos,end,1);
				printf("\tYou win!\n\n");
				Correct_rate = ((double)(step_count))/((double)(step_count) + (double)(fault_step_count));
				printf("失败次数%d，本次一共花了%d步走出此迷宫，期间撞墙%d次，正确率%.2f%%, 目前身体状况：",Lose_times,step_count,fault_step_count,Correct_rate*100);
				if (fault_step_count == 0)
				{
					printf("毫发无伤！");
				}
				else if (fault_step_count < 6)
				{
					printf("有轻微擦伤。\n");
				}
				else if (fault_step_count < 11)
				{
					printf("轻微脑震荡。");
				}
				else if (fault_step_count < 16)
				{
					printf("中度脑震荡。");
				}
				else if (fault_step_count < 21)
				{
					printf("重度脑震荡。");
				}
				else
				{
					printf("依然坚挺――练了铁头功。");
				}
				if (level)
				{
					Score += Level_score - (step_count + fault_step_count);
					printf("\n\n本关您的得分为%d分，累计得分%d分。",Level_score - (step_count + fault_step_count),Score);
				}
				while((ch=getchar()) != '\n');
				printf("\n\n\n按任意键结束探索...\n");
				getch();
				return OK;
			}
		}
		else
		{
			printf("\t  Bang!\n\n");
			Sleep(500);
			fault_step_count++;
			curpos = perpos;
			if (!H_Check(perpos))
			{
				system("cls");
				if (level)
				{
					Adv_Model_Title();
				}
				else
				{
					DIY_Model_H_Title();
				}
				printf("\n\n\n");
				Print_Image(m,x,y,begin,curpos,end,1);
				printf("\tYou Lose!\n\n");				
				Correct_rate = ((double)(step_count))/((double)(step_count) + (double)(fault_step_count));
				printf("一共走了%d步，撞墙%d次，正确率%.2f%%",step_count,fault_step_count,Correct_rate*100);
				if (level < 6)
				{
					printf("\n\n5秒后进行选择(现在不要按键)........");
					for (i = 5; i >= 0;i--)
					{	
						printf("\b\b\b\b\b(%d秒)",i);
						Sleep(1000);
					}
				}
				else
				{
					printf("，9秒后进行选择(现在不要按键)........");
					for (i = 9; i >= 0;i--)
					{	
						printf("\b\b\b\b\b(%d秒)",i);
						Sleep(1000);
					}
				}
				system("cls");
				return ERROR;
			}
			system("cls");
			if (level)
			{
				Adv_Model_Title();
			}
			else
			{
				DIY_Model_H_Title();
			}
			printf("\n\n\n");
			Print_Image(m,x,y,begin,curpos,end,image_type);
		}
	}while(1);
	
	return OK;
}

char MazeHpath_and_ask()
{
	char ch;
	do
	{
		system("cls");
		if (!(MazeHpath(begin, end,0)))
		{
			Lose_times++;
			if (level)
			{
				Adv_Model_Title();
			}
			else
			{
				DIY_Model_H_Title();
			}
			while((ch=getchar()) != '\n');
			printf("是否再尝试一次？(Y/N）:");
			scanf(" %c",&ch);
			if ('n' != ch && 'N' != ch)
			{
				ch = 'Y';
			}
		}
		else
		{
			system("cls");
			if (level)
			{
				Adv_Model_Title();
			}
			else
			{
				DIY_Model_H_Title();
			}
			printf("\n");
			printf("对您的成绩是否满意？(Y/N)如不满意按N重新尝试:");
			scanf(" %c",&ch);
			if ('N'!= ch && 'n'!= ch)
			{
				break;
			}
			ch = 'Y';
			if (Level_score)
			{
				Score -= Level_score - (step_count + fault_step_count);
			}
		}
	    Maze_copy(back_up,m);//重新开始本关
	}while('Y'== ch || 'y' == ch);
	return ch;
}

void Maze_Cover_and_ask(void)
{
	int i;
	Print_Image(m,x,y,begin,begin,end,1);
	if (level < 6)
	{
		printf("\n\n您有5秒时间观察迷宫格局，5秒后迷宫将被黑暗笼罩........");
		for (i = 5; i >= 0;i--)
		{	
			printf("\b\b\b\b\b(%d秒)",i);
			Sleep(1000);
		}
	}
	else
	{
		printf("\n\n您有9秒时间观察迷宫格局，9秒后迷宫将被黑暗笼罩........");
		for (i = 9; i >= 0;i--)
		{	
			printf("\b\b\b\b\b(%d秒)",i);
			Sleep(1000);
		}
	}
	system("cls");
}

void Adventure_Model(FILE*&fp,Status &st)
{
	char ch;
	int i;
	char nul[5] = "NULL";
	strcpy(filename,nul);
    if (!Date_Read(1))
	{
		level = 1;
		Score = 0;
		Date_Save(1);
	}
	else
	{
		system("cls");
		if (level > 0)
		{
			printf("/*****************************************************【存档选择】*****************************************************/\n");
			printf("\n您上次玩到第%d关，是否载入？(Y/N),选N则从第一关开始游戏:",level);
			scanf(" %c",&ch);
		}
		else
		{
			if (level)
			{
				Adv_Model_Title();
			}
			printf("\n伟大的探险者！您已经成功闯过所有迷宫，您想重新探索一次吗？(Y/N):");
			scanf(" %c",&ch);
			if ('Y'== ch || 'y' == ch)
			{
				ch = 'N';
			}
			else
			{
				return;
			}
		}
		if ('N'!= ch && 'n' != ch)
		{
			;
		}
		else
		{
			char nul[5] = "NULL";
			strcpy(filename,nul);
			level = 1;
			Score = 0;
			Date_Save(1);
		}
	}
	system("cls");
	Adv_Model_Title();
	printf("\n【游戏规则说明】：在该模式下，您将扮演迷宫探索者，获胜的唯一条件是找到迷宫出口。\n");
	printf("                  您无法重新通过已走过的路径，必须一次性走出迷宫！\n\n");
	printf("\n【积分规则说明】：每关总分100，共10关，总分的高低与所走步数和撞墙次数成反比。\n\n\n");
	printf("【操作说明】：   'W'=上移,'A'=左移,'S'=下移,'D'=右移 (迷宫未生成前请不要按这几个键)\n");
	printf("\n\n按“回车键”开始您的迷宫探之旅。。。。。。\n");
	getch();
	do 
	{
		system("cls");
		Adv_Model_Title();
		printf("\n");
		Maze_Library_Init(level - 1,m);//自动初始化
		Adv_Model_Title();

		printf("\n第%d关\n\n",level);
		Maze_Cover_and_ask();
		Adv_Model_Title();
		printf("\n");
		ch  = MazeHpath_and_ask();
		if ('N' != ch && 'n' != ch)
		{
			level++;
			if (level < LEVEL_SUM + 1)
			{
				system("cls");
				Adv_Model_Title();
				printf("\n恭喜您通过第%d过关!!!\n",level - 1);
				FileMake_ask(fp,st,-1);
				Date_Save(1);
				Lose_times = 0;
				system("cls");
				Adv_Model_Title();
				printf("\n");
				while((ch=getchar()) != '\n');
				printf("是否进入下一关(Y/N):");
				scanf(" %c",&ch);				
			}
			else
			{
				system("cls");
				Adv_Model_Title();
				printf("\n");
				printf("\n\n\n\n\n\n\t\t\t\t\t\t    恭喜您通关！！！\n");
				level = -1;
				Date_Save(1);
				Sleep(2000);
				system("cls");
				for (i = 0; i < 15; i++)
				{
					victory();
				}
				level = LEVEL_SUM + 1;
				FileMake_ask(fp,st,-1);
				ch = 'N';
			}
		}
			
	}while ('Y'== ch || 'y' == ch);
	return;
}

void DIY_Model(void)
{
	char ch;
	level = 0;
	Status imp;//标记文件输出
	char nul[5] = "NULL";
	strcpy(filename,nul);
    Date_Read(0);
	do
	{
		system("cls");
		printf("/**************************************************【DIY布局模式选择】***************************************************/\n");
		printf("\n请选择迷宫布局模式(H=即时手动布局，I=导入文件布局 )");
		scanf(" %c",&ch);
		system("cls");
		if ('H' == ch || 'h' == ch)
		{	
			Init();// 手动初始化
			while((ch=getchar()) != '\n');
			printf("\n对即时绘制的迷宫是否满意？(Y/N) 如不满意请输入N进行重新布局:");			
			scanf(" %c",&ch);
			printf("\n");
		 }
		else
		{
			system("cls");
			imp = Import_Init();
			while(!imp)
			{
				while((ch=getchar()) != '\n');
				printf("\n\n导入失败！请检查导入文件,仔细阅读导入说明\n\n");
				printf("\n想再次尝试导入吗？(Y/N):");
				scanf(" %c",&ch);
				if ('Y' != ch && 'y' != ch)
				{
					ch = 'o';
					break;
				}
				printf("\n\n按任意键重新导入\n\n");
				getch();
				system("cls");
				imp = Import_Init();
			}
			if ('o' != ch)
			{
				printf("\n\n对导入的迷宫是否满意(如果未按照布局的导入，可能您输错了行数和列数或文件内容不符合导入标准)？(Y/N) 如不满意请输入N进行重新布局:");			
				scanf(" %c",&ch);
				printf("\n");
			}
			else
			{
				ch = 'N';
			}
			
		}

	}while('N' == ch || 'n' == ch);

	return;
}

int main(void)
{
	FILE* fp;
	Status st = 0;//标记文件输出
	char ch;
	int i;
	system("color 30");
	system("mode con cols=120 lines=43");
	HANDLE hOut=GetStdHandle(STD_OUTPUT_HANDLE);
	COORD bufferSize={0};
	bufferSize.X = 160;bufferSize.Y = 120;
	SetConsoleScreenBufferSize(hOut,bufferSize);

	printf("/*************************************************  迷 宫 v1.0  ************************************************/\n");
	printf("\n\n  【责任声明】：1.本软件为共享软件，仅供学习娱乐，不得用于任何商业用途，版权归作者所有；\n");
	printf("\t\t2.在软件运行过程中，请按软件要求的格式输入，如果未提示输入，切勿按键；\n\t\t3.本软件不作任何保证，程序运行的风险由用户承担。");
	printf("\n\n\t\t我接受上述条款(Y/N)：");
	scanf(" %c",&ch);
	if ('Y' != ch && 'y' != ch)
	{
		return 0;
	}
/*	Maze_Library_Init(-1,m);
	Print_Image(m,x,y,begin,begin,end,1);
	getch();
//	MazeHpath(begin,end,1);
//	getch();
*/	
	system("cls");
	for (i = 0;i < 3;i++)
	{
		Countdown();
	}
	do
	{
		system("cls");
		printf("/******************************************************【游戏模式】**************************************************/\n");
		printf("\n请选择游戏模式 (A=冒险模式,D=自由DIY模式)：");
		scanf(" %c",&ch);
	
		if ('A' == ch || 'a' == ch)
		{
			Adventure_Model(fp,st);
		}
		else
		{
            DIY_Model();
			printf("5秒后请选择迷宫探索方式(现在不要按任何键)........");
			for (i = 5; i >= 0; i--)
			{
				printf("\b\b\b\b\b(%d秒)",i);
				Sleep(1000);
			}
			system("cls");
			printf("/**************************************************【DIY探险方式选择ing】************************************************/\n");
			while((ch=getchar()) != '\n');
			printf("\n(您可邀请的您朋友来手动探索,当然，您也可以选择由程序自动探索)\n");
			printf("\n请选择迷宫探索方式(A=自动探索,H=手动探索):");
			scanf(" %c",&ch);
			if ('A' == ch || 'a' == ch)
			{
				system("cls");
				DIY_Model_A_Title();
				MazePath_and_ask(fp,st);
				while((ch=getchar()) != '\n');
				printf("\n\n是否手动探索？(Y/N):");
				scanf(" %c",&ch);
				if ('N'!= ch && 'n' != ch)
				{
					Lose_times = 0;
					system("cls");
					DIY_Model_H_Title();
					Maze_Cover_and_ask();
					MazeHpath_and_ask();
					FileMake_ask(fp,st,0);
					Date_Save(0);
				}	
			}
			else
			{
				Lose_times = 0;
				system("cls");
				DIY_Model_H_Title();
				printf("\n\n【游戏规则说明】：在该模式下，您将探索DIY迷宫，获胜的唯一条件是找到迷宫出口。\n");
				printf("                  您无法重新通过已走过的路径，必须一次性走出迷宫！\n\n");
				printf("【操作说明】：   'w'=上移,'a'=左移,'s'=下移,'d'=右移 (迷宫未生成前请不要按这几个键)\n");
				printf("\n\n\n按“回车键”开始探索DIY迷宫。。。。。。\n");
				getch();
				system("cls");
				DIY_Model_H_Title();
				Maze_Cover_and_ask();
				MazeHpath_and_ask();
				FileMake_ask(fp,st,0);
				Date_Save(0);
				system("cls");
				DIY_Model_H_Title();
				while((ch=getchar()) != '\n');
				printf("\n是否自动探索？(Y/N):");
				scanf(" %c",&ch);
				if ('N'!= ch && 'n' != ch)
				{
				  system("cls");
				  Maze_copy(back_up,m);
			      DIY_Model_A_Title();
				  MazePath_and_ask(fp,st);
				}
			}
	}
	
		system("cls");
		printf("/**************************************************【结束】************************************************/\n");
		while((ch=getchar()) != '\n');
		printf("\n您想从头开始运行程序吗？(Y/N):");
		scanf(" %c",&ch);
		system("cls");
		if ('Y'== ch || 'y' == ch)
		{
			while((ch=getchar()) != '\n');
			ch = 'Y';
		}

	}while('Y'== ch || 'y' == ch);	

	if (LEVEL_SUM + 1 == level)
	{
		if (OK == st && !((fp = fopen(filename,"a+")) == NULL))
		{
			fprintf(fp,"                                (c) 2012 TLJ. All rights reserved.TLJ\n");
			fprintf(fp,"                                       Zhejianggongshang Unversity\n"); 
			fprintf(fp,"                                                2012.4.6\n");
			fclose(fp);
			fp = NULL;
		}	
	}
	else
	{
		if (OK == st && !((fp = fopen(filename,"a+")) == NULL))
		{
			fprintf(fp,"------------------------------------------------------------------------------------\n\n\n");
			fclose(fp);
			fp = NULL;
		}	
	}
    printf("\n\n\n\n\n\n\t\t\t\t\t\t   感谢您的支持！！！");
	Sleep(2000);
	system("cls");
	printf("\n\n\n\n\n\n\t\t\t\t\t\t  开发者：唐柳军\n\n\t\t\t\t\t\t浙江工商大学2010级\n\n\t\t\t\t\t\t   QQ:991025437\n\n\t\t\t\t\t\t     2012.4.6\n");
	printf("\n\n");
	Sleep(3000);
	return 0;
}
