/*****************main.cpp*****************/
#include "Sq_QuitSort.h"
#include <stdio.h>

int main(void)
{
	FILE *f; 
	SqList m; 
	int i;
    f=fopen("1.txt","r"); 
    fscanf(f,"%d",&m.length); 
    for(i=1;i<=m.length;i++) 
    {  
	    InputFromFile(f,m.r[i]); 
	}
	fclose(f);  
    printf("排序前：\n");
    PrintL(m); 
	QuikSort(m); 
    printf("快速排序后：\n");
    PrintL(m); 

	return 0;
}

//排序前按乱序
//(20,1) (17,2) (65,3) (97,4) (76,5) (13,6) (27,7) (49,8) (49,9)

//P1,P2处理乱序
//第1趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (97,4) (76,5) (65,3) (27,7) (49,8) (49,9)
//第2趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (97,4) (76,5) (65,3) (27,7) (49,8) (49,9)
//第3趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (49,9) (76,5) (65,3) (27,7) (49,8) (97,4)
//第4趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (27,7) (49,9) (65,3) (76,5) (49,8) (97,4)
//第5趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (27,7) (49,9) (49,8) (65,3) (76,5) (97,4) #第5趟排好  共5趟

//P3处理乱序
//第1趟排序后 顺序表L:
//(20,1) (17,2) (27,7) (13,6) (49,9) (76,5) (97,4) (49,8) (65,3)
//第2趟排序后 顺序表L:
//(13,6) (17,2) (27,7) (20,1) (49,9) (76,5) (97,4) (49,8) (65,3)
//第3趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (27,7) (49,9) (76,5) (97,4) (49,8) (65,3)
//第4趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (27,7) (49,9) (65,3) (49,8) (76,5) (97,4)
//第5趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (27,7) (49,9) (49,8) (65,3) (76,5) (97,4) #第5趟排好  共5趟

//P4处理乱序
//第1趟排序后 顺序表L:
//(17,2) (20,1) (27,7) (13,6) (49,9) (76,5) (97,4) (49,8) (65,3)
//第2趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (27,7) (49,9) (76,5) (97,4) (49,8) (65,3)
//第3趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (27,7) (49,9) (76,5) (97,4) (49,8) (65,3)
//第4趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (27,7) (49,9) (65,3) (49,8) (76,5) (97,4)
//第5趟排序后 顺序表L:
//(13,6) (17,2) (20,1) (27,7) (49,9) (49,8) (65,3) (76,5) (97,4) #第5趟排好  共5趟


//排序前逆序：
//(9,1) (8,2) (7,3) (6,4) (5,5) (4,6) (3,7) (2,8) (1,9)


//P1 P2处理按逆序：
//第1趟排序后 顺序表L:
//(1,9) (8,2) (7,3) (6,4) (5,5) (4,6) (3,7) (2,8) (9,1)
//第2趟排序后 顺序表L:
//(1,9) (8,2) (7,3) (6,4) (5,5) (4,6) (3,7) (2,8) (9,1)
//第3趟排序后 顺序表L:
//(1,9) (2,8) (7,3) (6,4) (5,5) (4,6) (3,7) (8,2) (9,1)
//第4趟排序后 顺序表L:
//(1,9) (2,8) (7,3) (6,4) (5,5) (4,6) (3,7) (8,2) (9,1)
//第5趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (6,4) (5,5) (4,6) (7,3) (8,2) (9,1)
//第6趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (6,4) (5,5) (4,6) (7,3) (8,2) (9,1)
//第7趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (6,4) (7,3) (8,2) (9,1)  # 第7趟排好
//第8趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (6,4) (7,3) (8,2) (9,1)  共8趟
//请按任意键继续. . .

//P3处理逆序：
//第1趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (9,1) (6,4) (7,3) (8,2)
//第2趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (9,1) (6,4) (7,3) (8,2)
//第3趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (9,1) (6,4) (7,3) (8,2)
//第4趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (7,3) (6,4) (8,2) (9,1)
//第5趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (6,4) (7,3) (8,2) (9,1)  # 第5趟排好  共5趟 
//请按任意键继续. . .

//P3处理逆序：
//第1趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (9,1) (6,4) (7,3) (8,2)
//第2趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (9,1) (6,4) (7,3) (8,2)
//第3趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (9,1) (6,4) (7,3) (8,2)
//第4趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (6,4) (7,3) (8,2) (9,1)  #第4趟排好  共5趟
//第5趟排序后 顺序表L:
//(1,9) (2,8) (3,7) (4,6) (5,5) (6,4) (7,3) (8,2) (9,1)
//请按任意键继续. . .


//排序前按顺序：
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)

//P1 P2处理顺序：
//第1趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9) 
//第2趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)
//第3趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)
//第4趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)
//第5趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)
//第6趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)
//第7趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)
//第8趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)  共8趟

//P3处理顺序：
//第1趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9) 
//第2趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)
//第3趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)
//第4趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)
//第5趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (4,4) (5,5) (6,6) (7,7) (8,8) (9,9)  共5趟

//P4处理顺序：
//第1趟排序后 顺序表L:
//(1,1) (2,2) (3,3) (1,1) (5,5) (6,6) (7,7) (8,8) (9,9) 
//第2趟排序后 顺序表L:
//(1,1) (1,1) (2,2) (3,3) (5,5) (6,6) (7,7) (8,8) (9,9)
//第3趟排序后 顺序表L:
//(1,1) (1,1) (2,2) (3,3) (5,5) (6,6) (7,7) (8,8) (9,9)
//第4趟排序后 顺序表L:
//(1,1) (1,1) (2,2) (3,3) (5,5) (6,6) (7,7) (8,8) (9,9)
//第5趟排序后 顺序表L:
//(1,1) (1,1) (2,2) (3,3) (5,5) (6,6) (7,7) (8,8) (9,9)  共5趟

//排序性能分析：
//当序列按乱序排列时，P1,P2,P3的平均性能相差不大
//当序列按逆序排列时,平均性能P4 > P3 > P1,P2
//当序列按顺序排列时,平均性能P4 = P3 > P1,P2
//P1,P2处理乱序序列时的性能优于处理顺序和逆序序列时的性能
//综上所述，P4算法平均排序性能最好