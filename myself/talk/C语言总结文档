C语言聊天程序总结文档

程序名称：C语言聊天程序

程序功能：实现点对点对话，扩展功能多对一对话。

平台工具：RHEL6.0系统，Vi编辑器，gcc4.5编译器。

应用技术：C语言网络编程，基于TCP协议socket通信，多线程。

设计思路：客户端同时作为服务器，实现接收发送信息过程。

问题及解决办法：

1、实现对话基本思想：
对话即通信，首先想到网络编程，并选取TCP通信协议，C/S模式。

2、点对点，客户端如何接收服务器信息：
程序最初分为客户端及服务器两部分。所以在服务器端一边在主进程接收来自客户端的信息（read），一边创建一个线程，专门负责服务器向外发送信息（send）；在客户端一边在主进程发送信息（write），一边创建一个线程等待来自服务器的信息（recv）。
3、客户端发出信息，同时被自己接收问题：
连接聊天两端的，本质上是一个socket套接字（程序中定义为sockfd）描述的文件，那么我向这个文件写入数据，会被在另一端等待的人接收，谁是等待的人？服务器，还有就是客户端自己。因为要从服务器接收信息，这样就会使用recv函数,并将sockfd作为参数，即从sockfd中read数据，这样就出现接收了自己发送的数据，对话布局显得混乱。
解决这个问题，关键还要将 客户端发送信息使用的套接字和接收信息的套接字分开，那么，我的知识范畴内，只能是在客户端加入“服务器”属性，再将服务器加入“客户端”属性，均放入线程中去处理，以此来解决以上问题。
这样整个运行过程就是这样的，首先运行服务器A，并被accept阻塞，然后运行客户端B，接着B-->A两端连接成功，然后B创建“服务器”线程准备accept，A创建“客户端”线程，A-->B连接成功，通信正常。

4、点对点，一方下线后自动杀死连接进程：
服务器A，客户端B，A<-->B，正在通信，突然B不高兴下线了，这样B的主进程就结束了。但A中“客户端”线程仍然在运行，当B重新连接，A中又会创建一个新的“客户端”线程，当AB再次通话时，A的信息会被两个“客户端”线程竞争发送出去，但先前的线程发送的信息没人会接受，这样就出现，A的一部分信息被“吃掉了”，导致B下线后再连接，A信息缺失问题。
解决问题关键在于B下线后，A中“客户端”线程应该被杀死，那么在接受到B下线的信号时执行pthread_cancel(tid)（这个函数开始不知道），将相应的线程杀掉即可！

5、多对一对话的尝试：
服务器A，客户端B。为现实多对一对话，A必须有能同时跟多个B进行连接的能力，那么，我将A接受信息部分也放入线程，即来一个客户端连接到A ，A就创建两个线程，一个负责接受信息，一个是“客户端”线程用来发送信息。

6、多对一对话，问题4再现：
服务器A，客户端B1，B2，在多对一通信时（以两个为例），问题4是由于A中存在两个线程都是用来发送信息的，但是好在其中之一是无用的，那么我们“杀死”它就OK了！但这次是B1,B2同时跟B连接，即A<-->B1  &&  A<-->B2，这样A中必然出现两个线程，并且都有用，我不能杀掉然任何一个！这个问题遗留了下来，望今后能够完善起！

